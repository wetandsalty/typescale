<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Type Scale Visualization</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      font-family: system-ui, sans-serif;
      margin: 40px;
      background: #fafafa;
    }
    h1, h2, h3 { margin-bottom: 1.25em; }

    .controls {
      display: flex;
      margin-bottom: 1em;
      flex-flow: column;
      justify-content: left;
      gap: 10px;
      padding: 12px;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 12px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.05);
      max-width: 560px;
    }
    .label-input {
      display: grid;
      grid-template-columns: 220px 1fr;
      align-items: center;
      gap: 10px;
    }
    input[type="number"], select {
      padding: 6px 8px;
      font-size: 14px;
      border: 1px solid #ccc;
      border-radius: 8px;
      background: white;
    }
    select { min-width: 140px; }

    svg {
      width: 100%;
      height: auto;
      background: white;
      border: 1px solid #ccc;
      border-radius: 12px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.05);
      cursor: pointer;
      margin: 2em 0;
    }
    .line { fill: none; stroke: #00e0e0; stroke-width: 2.5px; }
    .dot { fill: black; }
    .half-dot { fill: white; stroke: #00e0e0; stroke-width: 2px; }
    .base-dot { fill: black; stroke: #00e0e0; stroke-width: 3px; }
    .cursor-line { stroke: black; stroke-width: 1.5px; stroke-dasharray: 4 2; }
    .label-graph { font-size: 0.5em; font-weight: 600; }
    .label-axis { font-size: 0.6em; font-weight: 400; }
    .tooltip {
      font-size: 13px;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid #ccc;
      padding: 4px 6px;
      border-radius: 4px;
      pointer-events: none;
      position: absolute;
    }

    .table { margin: 80px 0 0 0; }
    #table-container, #distance-table-container {
      margin: 0;
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
    }
    table {
      margin-top: 20px;
      border-collapse: collapse;
      width: max-content;
      min-width: 100%;
      background: #fff;
    }
    td, th {
      border: 1px solid #ccc;
      padding: 6px 10px;
      text-align: right;
      white-space: nowrap;
    }
    th { background: #f0f0f0; text-align: center; }

    .distance-section { margin-top: 70px; }
    .note { color: #555; font-size: 14px; }
    .sticky-left { text-align: left; }
  </style>
</head>
<body>
  <h1>Type Scale Visualization</h1>

  <p>The base font size is 12&ThinSpace;mm. Hover over the graph to see the value at each step and click to copy!</p>

  <svg id="chart" viewBox="0 0 800 400" preserveAspectRatio="xMidYMid meet"></svg>

  <section class="table">
    <h2>Type scale table</h2>
    <p class="note">
      * Font size 2 (= 8&ThinSpace;mm) is set manually. It should actually be rounded up from 8.67&ThinSpace;mm to 9&ThinSpace;mm, but we rounded down for now, because otherwise it would just be 1mm difference to font size 2.5
    </p>
    <div id="table-container">
      <table id="type-table">
        <thead>
          <tr>
            <th>Step</th>
            <th>Font Size (mm)</th>
            <th>Font Size (pt)</th>
            <th>Line Height (mm)</th>
            <th>Line Height (pt)</th>
            <th>x-Height (mm)</th>
            <th>Cap Height (mm)</th>
            <th>Visus 0.1 (m)</th>
            <th>Visus 0.3 (m)</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>

    <!-- Reading distance table -->
    <div class="distance-section">
      <h2>Reading distance table (by mounting height)</h2>

      <div class="controls">
        <label class="label-input">
          <span>Anbringungshöhe a (cm)</span>
          <input type="number" id="mountHeightInput" value="120" min="0" step="1" />
        </label>

        <label class="label-input">
          <span>Schriftgrad (Step)</span>
          <select id="schriftgradSelect"></select>
        </label>

        <div class="note">
          g = 90° (fix), h1 = 170&nbsp;cm, h2 = 110&nbsp;cm.
          (Für Schriftgrad 6,5 und a=120&nbsp;cm liefert das z.B. 0,35–0,71 / 0,081–3,101 / 0,034–7,391&nbsp;m bei 170&nbsp;cm.)
        </div>
      </div>

      <div id="distance-table-container">
        <table id="distance-table">
          <thead>
            <tr>
              <th class="sticky-left" rowspan="2">Schriftgrad</th>
              <th colspan="3">Augenhöhe = 170cm</th>
              <th colspan="3">Augenhöhe = 110cm</th>
            </tr>
            <tr>
              <th>Visus 0,1</th>
              <th>Visus 0,3</th>
              <th>Visus 0,7</th>
              <th>Visus 0,1</th>
              <th>Visus 0,3</th>
              <th>Visus 0,7</th>
            </tr>
          </thead>
          <tbody id="distance-table-body"></tbody>
        </table>
      </div>
    </div>
  </section>

<script>
  const xFactor = 0.5176;
  const capFactor = 0.71680;
  const ratio = capFactor / xFactor;
  const maxStep = 13;
  const mmToPt = 2.8346;

  // displayed step = internal + 2
  const stepOffset = 2;

  const svg = d3.select("#chart");
  const width = 800, height = 400;
  const margin = { top: 20, right: 20, bottom: 60, left: 60 };
  const innerWidth = width - margin.left - margin.right;
  const innerHeight = height - margin.top - margin.bottom;
  const x = d3.scaleLinear().domain([0, maxStep + 0.2]).range([0, innerWidth]);
  const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);
  const yAxisGroup = g.append("g");
  const xAxisGroup = g.append("g").attr("transform", `translate(0,${innerHeight})`);
  g.append("text").attr("x", innerWidth / 2).attr("y", innerHeight + 40)
    .attr("fill", "black").attr("text-anchor", "middle").attr("class", "label-axis").text("steps");
  g.append("text").attr("transform", "rotate(-90)").attr("x", -innerHeight / 2).attr("y", -40)
    .attr("fill", "black").attr("text-anchor", "middle").attr("class", "label-axis").text("font size");

  const curveGroup = g.append("path").attr("class", "line");
  const dotsGroup = g.append("g");
  const labelsGroup = g.append("g");
  const cursorLine = g.append("line").attr("class", "cursor-line").attr("y1", 0).attr("y2", innerHeight).style("display", "none");
  const tooltip = d3.select("body").append("div").attr("class", "tooltip").style("display", "none");
  const tableBody = d3.select("#type-table tbody");

  // Distance-table elements
  const mountHeightInput = document.getElementById("mountHeightInput");
  const schriftgradSelect = document.getElementById("schriftgradSelect");
  const distanceTableBody = document.getElementById("distance-table-body");

  // Original visus distance (kept for the existing table columns)
  function getVisusDistance(xHeight, visus = 0.1) {
    const Lf = 0.7;
    const Klv = Lf / visus;
    const sW = 9;
    const r = (sW / 60) * (Math.PI / 180);
    const d_mm = xHeight / (2 * Math.tan((r * Klv) / 2));
    return d_mm / 1000;
  }

  function getDistanceColor(distance) {
    if (distance < 1) return "#ffb3b3";
    if (distance < 2) return "#ffd9b3";
    if (distance < 4) return "#fff5b3";
    if (distance < 10) return "#d4f8b3";
    return "#b3e0ff";
  }

  // ----------------------------
  // Formula model (g fixed 90°) -> closed form
  // With g = 90°: sin(|g - atan((a-h)/d)|) simplifies and the formula becomes:
  // V(d) = 1.830 * (d^2 + (a-h)^2) / (s * d)
  //
  // IMPORTANT: Here we use the "scaled" target that matches your table:
  // Visus 0.1 -> 100, Visus 0.3 -> 300, Visus 0.7 -> 700
  // ----------------------------
  const K = 1.830;

  function solveIntervalForTargetScaled({ targetScaled, aMm, hMm, sMm }) {
    // Solve: K*d^2 - targetScaled*s*d + K*delta^2 = 0
    // Interval where V(d) <= targetScaled is between the two positive roots (if they exist).
    const delta = aMm - hMm;
    const A = K;
    const B = -targetScaled * sMm;
    const C = K * (delta * delta);

    const D = B * B - 4 * A * C;
    if (D <= 0) return null;

    const sqrtD = Math.sqrt(D);
    const d1 = (-B - sqrtD) / (2 * A);
    const d2 = (-B + sqrtD) / (2 * A);

    const lo = Math.min(d1, d2);
    const hi = Math.max(d1, d2);

    // Only keep positive distances
    if (hi <= 0) return null;
    return { dMinMm: Math.max(lo, 0), dMaxMm: hi };
  }

  function fmtDE(num, decimals) {
    return num.toFixed(decimals).replace(".", ",");
  }

  function formatRangeMetersFromMm(dMinMm, dMaxMm) {
    const minM = dMinMm / 1000;
    const maxM = dMaxMm / 1000;

    const decMin = minM < 1 ? 3 : 2;
    const decMax = maxM < 1 ? 3 : 2;

    return `${fmtDE(minM, decMin)} m – ${fmtDE(maxM, decMax)} m`;
  }

  function renderDistanceTable({ xHeightMm, displayStep }) {
    const a_cm = parseFloat(mountHeightInput.value);
    const aMm = (isFinite(a_cm) ? a_cm : 0) * 10; // cm -> mm

    const sMm = xHeightMm; // already mm

    const eyes = [
      { label: "170", hMm: 1700 },
      { label: "110", hMm: 1100 },
    ];

    // scaled targets: 0.1->100, 0.3->300, 0.7->700
    const targets = [100, 300, 700];

    distanceTableBody.innerHTML = "";

    const tr = document.createElement("tr");

    const tdStep = document.createElement("td");
    tdStep.className = "sticky-left";
    tdStep.style.textAlign = "left";
    tdStep.textContent = displayStep;
    tr.appendChild(tdStep);

    for (const eye of eyes) {
      for (const t of targets) {
        const interval = solveIntervalForTargetScaled({
          targetScaled: t,
          aMm,
          hMm: eye.hMm,
          sMm
        });

        const td = document.createElement("td");
        if (!interval) {
          td.textContent = "—";
        } else {
          td.textContent = formatRangeMetersFromMm(interval.dMinMm, interval.dMaxMm);
        }
        tr.appendChild(td);
      }
    }

    distanceTableBody.appendChild(tr);
  }

  function render() {
    const baseSize = 12;
    const baseStep = 1;
    const S = step => baseSize * Math.pow(ratio, step - baseStep);
    const xFromFont = fontSize => fontSize * xFactor;
    const capFromFont = fontSize => fontSize * capFactor;

    const curvePoints = d3.range(0, maxStep + 0.05, 0.05).map(xx => ({ step: xx, size: S(xx) }));
    const fullSteps = d3.range(0, maxStep + 1).map(i => ({ step: i, size: S(i) }));
    const halfSteps = d3.range(0.5, maxStep, 1).map(i => ({ step: i, size: S(i) }));

    const y = d3.scaleLinear().domain([0, d3.max(curvePoints, d => d.size)]).range([innerHeight, 0]);

    xAxisGroup.call(
      d3.axisBottom(x)
        .ticks(maxStep * 2)
        .tickFormat(d => {
          const display = d + stepOffset;
          return Number.isInteger(d) ? display : display.toFixed(1);
        })
    );

    yAxisGroup.call(d3.axisLeft(y));

    const line = d3.line().x(d => x(d.step)).y(d => y(d.size));
    curveGroup.datum(curvePoints).attr("d", line);

    dotsGroup.selectAll("*").remove();
    dotsGroup.append("circle").attr("class", "base-dot")
      .attr("cx", x(baseStep)).attr("cy", y(S(baseStep))).attr("r", 6);

    dotsGroup.selectAll(".dot").data(fullSteps).enter().append("circle")
      .attr("class", "dot").attr("cx", d => x(d.step)).attr("cy", d => y(d.size)).attr("r", 4);

    dotsGroup.selectAll(".half-dot").data(halfSteps).enter().append("circle")
      .attr("class", "half-dot").attr("cx", d => x(d.step)).attr("cy", d => y(d.size)).attr("r", 4);

    labelsGroup.selectAll("*").remove();
    labelsGroup.selectAll(".label-full").data(fullSteps).enter().append("text")
      .attr("x", d => x(d.step) + 5).attr("y", d => y(d.size) - 5)
      .text(d => Math.round(d.size)).attr("class", "label-graph").attr("fill", "#333");

    labelsGroup.selectAll(".label-half").data(halfSteps).enter().append("text")
      .attr("x", d => x(d.step) + 5).attr("y", d => y(d.size) - 5)
      .text(d => Math.round(d.size)).attr("class", "label-graph").attr("fill", "#00a0a0");

    // Update type table + build xHeight lookup by displayStep
    tableBody.selectAll("*").remove();
    const allSteps = fullSteps.concat(halfSteps).sort((a, b) => a.step - b.step);
    const xHeightByDisplayStep = new Map();

    allSteps.forEach(d => {
      const fontSize = d.step === 0 ? 8 : d.size;
      const displayStep = Number.isInteger(d.step)
        ? (d.step + stepOffset).toFixed(0)
        : (d.step + stepOffset).toFixed(1);

      const lineHeightMm = fontSize * 1.2;
      const lineHeightPt = lineHeightMm * mmToPt;
      const xHeight = xFromFont(fontSize);
      const capHeight = capFromFont(fontSize);
      const visus01 = getVisusDistance(xHeight, 0.1);
      const visus03 = getVisusDistance(xHeight, 0.3);
      const color01 = getDistanceColor(visus01);
      const color03 = getDistanceColor(visus03);

      xHeightByDisplayStep.set(displayStep, xHeight);

      tableBody.append("tr").html(
        `<td>${displayStep}</td>
         <td>${fontSize.toFixed(0)}</td>
         <td>${(fontSize * mmToPt).toFixed(2)}</td>
         <td>${lineHeightMm.toFixed(0)}</td>
         <td>${lineHeightPt.toFixed(2)}</td>
         <td>${xHeight.toFixed(2)}</td>
         <td>${capHeight.toFixed(2)}</td>
         <td style="background:${color01}">${visus01.toFixed(2)}</td>
         <td style="background:${color03}">${visus03.toFixed(2)}</td>`
      );
    });

    // Populate Schriftgrad select once
    if (schriftgradSelect.options.length === 0) {
      const keys = Array.from(xHeightByDisplayStep.keys()).sort((a, b) => parseFloat(a) - parseFloat(b));
      keys.forEach(k => {
        const opt = document.createElement("option");
        opt.value = k;
        opt.textContent = k.replace(".", ",");
        schriftgradSelect.appendChild(opt);
      });

      // default to 6.5 if present (matches your example)
      const preferred = "6.5";
      schriftgradSelect.value = keys.includes(preferred) ? preferred : keys[0];
    }

    function updateDistance() {
      const selRaw = schriftgradSelect.value;
      const xHeightMm = xHeightByDisplayStep.get(selRaw);
      if (!xHeightMm) return;
      renderDistanceTable({ xHeightMm, displayStep: selRaw.replace(".", ",") });
    }

    mountHeightInput.oninput = updateDistance;
    schriftgradSelect.onchange = updateDistance;
    updateDistance();

    // Graph interactions
    svg.on("mousemove", (event) => {
      const [mx] = d3.pointer(event, g.node());
      if (mx < 0 || mx > innerWidth) return;
      const stepValue = Math.round(x.invert(mx) * 2) / 2;
      const sizeValue = S(stepValue);
      const displayStep = stepValue + stepOffset;

      cursorLine.attr("x1", x(stepValue)).attr("x2", x(stepValue)).style("display", null);

      tooltip.style("display", "block")
        .style("left", (event.pageX + 10) + "px")
        .style("top", (event.pageY - 25) + "px")
        .html(`<strong>size:</strong> ${sizeValue.toFixed(2)} mm<br />
               <strong>step:</strong> ${displayStep.toFixed(2)}`);
    });

    svg.on("click", (event) => {
      const [mx] = d3.pointer(event, g.node());
      if (mx < 0 || mx > innerWidth) return;
      const stepValue = Math.round(x.invert(mx) * 4) / 4;
      const sizeValue = S(stepValue).toFixed(2);
      navigator.clipboard.writeText(sizeValue).then(() => {
        console.log("copied font size: " + sizeValue + " mm");
      });
    });

    svg.on("mouseleave", () => {
      cursorLine.style("display", "none");
      tooltip.style("display", "none");
    });
  }

  render();
</script>
</body>
</html>