<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Type Scale Visualization</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div class="content" id="index0">
    <nav>
      <ul class="navi">
        <li>
          <a href="#index1" class="navlink" title="Typografie-Skala"></a>
        </li>
        <li>
          <a href="#index2" class="navlink" title="Lesbarkeits-Check"></a>
        </li>
        <li>
          <a href="#index3" class="navlink" title="Visualisierung der Skala"></a>
        </li>
      </ul>
    </nav>

    <section class="intro">
      <h1>HHA FIS U5 Typografie-Skala</h1>

      <p>Auf dieser Seite befinden sich verschiedene Tools zur Berechnung und Darstellung der Schriftgrade des FIS U5, sowie ein Lesbarkeits-Check (auf Basis der Sehschärfe, d.h. des Visus, des Betrachtungs-Abstands und der Anbringungshöhe).</p>

      <p>Die Basis-Schriftgröße, an der sich die Berechnung aller Schriftgrade orientiert, ist der Schriftgrad 3 = 12&ThinSpace;mm.</p>

      <p class="note">
        * Der Schriftgrade 2 (= 8&ThinSpace;mm) wurde nicht anhand der normalen Berechnung festgelegt. Die berechneten 8,67 mm müssten eigentlich auf 9 mm aufgerundet werden. Wir haben aber abgerundet, da sonst zum Schriftgrad 2,5 nur ein fast nicht wahrnehmbarer Unterschied von 1 mm bestehen würde.
      </p>

      <h3>Auf dieser Seite:</h3>
      <ul class="kapitel">
        <li>
          <a href="#index1" class="kapitellink">→ Typografie-Skala</a>
        </li>
        <li>
          <a href="#index2" class="kapitellink">→ Lesbarkeits-Check</a>
        </li>
        <li>
          <a href="#index3" class="kapitellink">→ Visualisierung der Skala</a>
        </li>
      </ul>
    </section>

    <section id="index1" class="table">
      <h2><span class="red">01</span> Schriftgrade der Typografie-Skala</h2>

      <label style="display:inline-flex; gap:.5rem; align-items:center; margin:.5rem 0 1rem;">
        <input type="checkbox" id="togglePtCols">
        Schriftgröße und Zeilenhöhe in pt anzeigen
      </label>

      <div id="table-container">
        <table id="type-table">
          <thead>
            <tr>
              <th>Grad</th>
              <th>Schriftgröße (mm)</th>
              <th class="col-pt">Schriftgr. (pt)</th>
              <th>Zeilenhöhe (mm)</th>
              <th class="col-pt">Zeilenh. (pt)</th>
              <th>x-Höhe (mm)</th>
              <th>Majuskel (mm)</th>
              <th>Visus 0.1 (m)</th>
              <th>Visus 0.3 (m)</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </section>

    <section id="index2">
      <!-- Reading distance table (by mounting height) -->
        <h2><span class="red">02</span> Lesbarkeits-Check</h2>

        <p>Berechnet den Leseabstand eines Schriftgrads anhand der Anbringungshöhe</p>

        <div class="controls">
          <label class="label-input">
            <span>Anbringungshöhe a (cm)</span>
            <input type="number" id="mountHeightInput" value="120" min="0" step="1" />
          </label>

          <label class="label-input">
            <span>Schriftgrad</span>
            <select id="schriftgradSelect"></select>
          </label>

          <div class="note">
            g = 90° (fix), h1 = 170&nbsp;cm, h2 = 110&nbsp;cm.
            (Für Schriftgrad 6,5 und a=120&nbsp;cm liefert das z.B. 0,35–0,71 / 0,081–3,101 / 0,034–7,391&nbsp;m bei 170&nbsp;cm.)
          </div>
        </div>

        <div id="distance-table-container">
          <table id="distance-table">
            <thead>
              <tr>
                <th class="sticky-left" rowspan="2">Schriftgrad</th>
                <th colspan="3">Augenhöhe = 170cm</th>
                <th colspan="3">Augenhöhe = 110cm</th>
              </tr>
              <tr>
                <th>Visus 0,1</th>
                <th>Visus 0,3</th>
                <th>Visus 0,7</th>
                <th>Visus 0,1</th>
                <th>Visus 0,3</th>
                <th>Visus 0,7</th>
              </tr>
            </thead>
            <tbody id="distance-table-body"></tbody>
          </table>
        </div>
    </section>

    <section id="index3">
      <h2 id="index1"><span class="red">03</span> Visualisierung der Skala</h2>
      <svg id="chart" viewBox="0 0 800 400" preserveAspectRatio="xMidYMid meet"></svg>
      <a href="#index0" class="back-to-top">↑</a>
    </section>
  </div>
<script>
  const xFactor = 0.5176;
  const capFactor = 0.71680;
  const ratio = capFactor / xFactor;
  const maxStep = 13;
  const mmToPt = 2.8346;

  // Steps are 0.5 difference each, displayed step = internal step + 2
  const stepResolution = 0.5;
  const stepOffset = 2;

  function quantizeStep(step, res = stepResolution) {
    return Math.round(step / res) * res;
  }

  function formatDisplayStepFromInternalStep(step) {
    const display = step + stepOffset;
    return Number.isInteger(step) ? display.toFixed(0) : display.toFixed(1);
  }

  const svg = d3.select("#chart");
  const width = 800, height = 400;
  const margin = { top: 20, right: 20, bottom: 60, left: 60 };
  const innerWidth = width - margin.left - margin.right;
  const innerHeight = height - margin.top - margin.bottom;
  const x = d3.scaleLinear().domain([0, maxStep + 0.2]).range([0, innerWidth]);
  const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);
  const yAxisGroup = g.append("g");
  const xAxisGroup = g.append("g").attr("transform", `translate(0,${innerHeight})`);
  g.append("text").attr("x", innerWidth / 2).attr("y", innerHeight + 40)
    .attr("fill", "black").attr("text-anchor", "middle").attr("class", "label-axis").text("Schriftgrade");
  g.append("text").attr("transform", "rotate(-90)").attr("x", -innerHeight / 2).attr("y", -40)
    .attr("fill", "black").attr("text-anchor", "middle").attr("class", "label-axis").text("Schriftgröße");

  const curveGroup = g.append("path").attr("class", "line");
  const dotsGroup = g.append("g");
  const labelsGroup = g.append("g");
  const cursorLine = g.append("line").attr("class", "cursor-line").attr("y1", 0).attr("y2", innerHeight).style("display", "none");
  const tooltip = d3.select("body").append("div").attr("class", "tooltip").style("display", "none");
  const tableBody = d3.select("#type-table tbody");

  // Distance-table elements
  const mountHeightInput = document.getElementById("mountHeightInput");
  const schriftgradSelect = document.getElementById("schriftgradSelect");
  const distanceTableBody = document.getElementById("distance-table-body");

  // Original visus distance (kept for the existing table columns)
  function getVisusDistance(xHeight, visus = 0.1) {
    const Lf = 0.7;
    const Klv = Lf / visus;
    const sW = 9;
    const r = (sW / 60) * (Math.PI / 180);
    const d_mm = xHeight / (2 * Math.tan((r * Klv) / 2));
    return d_mm / 1000;
  }

  function getDistanceColor(distance) {
    if (distance < 1) return "#ffb3b3";
    if (distance < 2) return "#ffd9b3";
    if (distance < 4) return "#fff5b3";
    if (distance < 10) return "#d4f8b3";
    return "#b3e0ff";
  }

  // ----------------------------
  // Formula model (g fixed 90°) -> closed form
  // With g = 90°: sin(|g - atan((a-h)/d)|) simplifies and the formula becomes:
  // V(d) = 1.830 * (d^2 + (a-h)^2) / (s * d)
  //
  // IMPORTANT: Here we use the "scaled" target that matches your table:
  // Visus 0.1 -> 100, Visus 0.3 -> 300, Visus 0.7 -> 700
  // ----------------------------
  const K = 1.830;

  function solveIntervalForTargetScaled({ targetScaled, aMm, hMm, sMm }) {
    // Solve: K*d^2 - targetScaled*s*d + K*delta^2 = 0
    // Interval where V(d) <= targetScaled is between the two positive roots (if they exist).
    const delta = aMm - hMm;
    const A = K;
    const B = -targetScaled * sMm;
    const C = K * (delta * delta);

    const D = B * B - 4 * A * C;
    if (D <= 0) return null;

    const sqrtD = Math.sqrt(D);
    const d1 = (-B - sqrtD) / (2 * A);
    const d2 = (-B + sqrtD) / (2 * A);

    const lo = Math.min(d1, d2);
    const hi = Math.max(d1, d2);

    // Only keep positive distances
    if (hi <= 0) return null;
    return { dMinMm: Math.max(lo, 0), dMaxMm: hi };
  }

  function fmtDE(num, decimals) {
    return num.toFixed(decimals).replace(".", ",");
  }

  function formatRangeMetersFromMm(dMinMm, dMaxMm) {
    const minM = dMinMm / 1000;
    const maxM = dMaxMm / 1000;

    const decMin = minM < 1 ? 3 : 2;
    const decMax = maxM < 1 ? 3 : 2;

    return `${fmtDE(minM, decMin)} m – ${fmtDE(maxM, decMax)} m`;
  }

  function renderDistanceTable({ xHeightMm, displayStep }) {
    const a_cm = parseFloat(mountHeightInput.value);
    const aMm = (isFinite(a_cm) ? a_cm : 0) * 10; // cm -> mm

    const sMm = xHeightMm; // already mm

    const eyes = [
      { label: "170", hMm: 1700 },
      { label: "110", hMm: 1100 },
    ];

    // scaled targets: 0.1->100, 0.3->300, 0.7->700
    const targets = [100, 300, 700];

    distanceTableBody.innerHTML = "";

    const tr = document.createElement("tr");

    const tdStep = document.createElement("td");
    tdStep.className = "sticky-left";
    tdStep.style.textAlign = "left";
    tdStep.textContent = displayStep;
    tr.appendChild(tdStep);

    for (const eye of eyes) {
      for (const t of targets) {
        const interval = solveIntervalForTargetScaled({
          targetScaled: t,
          aMm,
          hMm: eye.hMm,
          sMm
        });

        const td = document.createElement("td");
        if (!interval) {
          td.textContent = "—";
        } else {
          td.textContent = formatRangeMetersFromMm(interval.dMinMm, interval.dMaxMm);
        }
        tr.appendChild(td);
      }
    }

    distanceTableBody.appendChild(tr);
  }

  function render() {
    const baseSize = 12;
    const baseStep = 1;
    const S = step => baseSize * Math.pow(ratio, step - baseStep);
    const xFromFont = fontSize => fontSize * xFactor;
    const capFromFont = fontSize => fontSize * capFactor;

    const curvePoints = d3.range(0, maxStep + 0.05, 0.05).map(xx => ({ step: xx, size: S(xx) }));
    const fullSteps = d3.range(0, maxStep + 1).map(i => ({ step: i, size: S(i) }));
    const halfSteps = d3.range(0.5, maxStep, 1).map(i => ({ step: i, size: S(i) }));

    const y = d3.scaleLinear().domain([0, d3.max(curvePoints, d => d.size)]).range([innerHeight, 0]);

    const tickVals = d3.range(0, maxStep + stepResolution, stepResolution);
    xAxisGroup.call(
      d3.axisBottom(x)
        .tickValues(tickVals)
        .tickFormat(formatDisplayStepFromInternalStep)
    );

    yAxisGroup.call(d3.axisLeft(y));

    const line = d3.line().x(d => x(d.step)).y(d => y(d.size));
    curveGroup.datum(curvePoints).attr("d", line);

    dotsGroup.selectAll("*").remove();
    dotsGroup.append("circle").attr("class", "base-dot")
      .attr("cx", x(baseStep)).attr("cy", y(S(baseStep))).attr("r", 6);

    dotsGroup.selectAll(".dot").data(fullSteps).enter().append("circle")
      .attr("class", "dot").attr("cx", d => x(d.step)).attr("cy", d => y(d.size)).attr("r", 4);

    dotsGroup.selectAll(".half-dot").data(halfSteps).enter().append("circle")
      .attr("class", "half-dot").attr("cx", d => x(d.step)).attr("cy", d => y(d.size)).attr("r", 4);

    labelsGroup.selectAll("*").remove();
    labelsGroup.selectAll(".label-full").data(fullSteps).enter().append("text")
      .attr("x", d => x(d.step) + 5).attr("y", d => y(d.size) - 5)
      .text(d => Math.round(d.size)).attr("class", "label-graph").attr("fill", "#333");

    labelsGroup.selectAll(".label-half").data(halfSteps).enter().append("text")
      .attr("x", d => x(d.step) + 5).attr("y", d => y(d.size) - 5)
      .text(d => Math.round(d.size)).attr("class", "label-graph").attr("fill", "rgba(0,0,0,0.5");

    // Update type table + build xHeight lookup by displayStep
    tableBody.selectAll("*").remove();
    const allSteps = fullSteps.concat(halfSteps).sort((a, b) => a.step - b.step);
    const xHeightByDisplayStep = new Map();

    allSteps.forEach(d => {
      const displayStep = formatDisplayStepFromInternalStep(d.step);
      const fontSize = displayStep === "2" ? 8 : d.size;

      const lineHeightMm = fontSize * 1.2;
      const lineHeightPt = lineHeightMm * mmToPt;
      const xHeight = xFromFont(fontSize);
      const capHeight = capFromFont(fontSize);
      const visus01 = getVisusDistance(xHeight, 0.1);
      const visus03 = getVisusDistance(xHeight, 0.3);
      const color01 = getDistanceColor(visus01);
      const color03 = getDistanceColor(visus03);

      xHeightByDisplayStep.set(displayStep, xHeight);

      tableBody.append("tr").html(
        `<td>${displayStep}</td>
         <td>${fontSize.toFixed(0)}</td>
         <td class="col-pt">${(fontSize * mmToPt).toFixed(2)}</td>
         <td>${lineHeightMm.toFixed(0)}</td>
         <td class="col-pt">${lineHeightPt.toFixed(2)}</td>
         <td>${xHeight.toFixed(2)}</td>
         <td>${capHeight.toFixed(2)}</td>
         <td style="background:${color01}">${visus01.toFixed(2)}</td>
         <td style="background:${color03}">${visus03.toFixed(2)}</td>`
      );
    });

    //functionality to show table columns with values in pt
    const togglePtCols = document.getElementById("togglePtCols");
    const typeTable = document.getElementById("type-table");
    togglePtCols.addEventListener("change", () => {
      typeTable.classList.toggle("show", togglePtCols.checked);
    });

    // Populate Schriftgrad select once
    if (schriftgradSelect.options.length === 0) {
      const keys = Array.from(xHeightByDisplayStep.keys()).sort((a, b) => parseFloat(a) - parseFloat(b));
      keys.forEach(k => {
        const opt = document.createElement("option");
        opt.value = k;
        opt.textContent = k.replace(".", ",");
        schriftgradSelect.appendChild(opt);
      });

      // default to 6.5 if present (matches your example)
      const preferred = "6.5";
      schriftgradSelect.value = keys.includes(preferred) ? preferred : keys[0];
    }

    function updateDistance() {
      const selRaw = schriftgradSelect.value;
      const xHeightMm = xHeightByDisplayStep.get(selRaw);
      if (!xHeightMm) return;
      renderDistanceTable({ xHeightMm, displayStep: selRaw.replace(".", ",") });
    }

    mountHeightInput.oninput = updateDistance;
    schriftgradSelect.onchange = updateDistance;
    updateDistance();

    // Graph interactions
    svg.on("mousemove", (event) => {
      const [mx] = d3.pointer(event, g.node());
      if (mx < 0 || mx > innerWidth) return;

      const stepValue = quantizeStep(x.invert(mx)); // <-- 0.5 steps
      const sizeValue = S(stepValue);
      const displayStep = formatDisplayStepFromInternalStep(stepValue);

      cursorLine
        .attr("x1", x(stepValue))
        .attr("x2", x(stepValue))
        .style("display", null);

      tooltip.style("display", "block")
        .style("left", (event.pageX + 10) + "px")
        .style("top", (event.pageY - 25) + "px")
        .html(`<strong>size:</strong> ${sizeValue.toFixed(2)} mm<br />
               <strong>step:</strong> ${displayStep}`);
    });

    svg.on("mouseleave", () => {
      cursorLine.style("display", "none");
      tooltip.style("display", "none");
    });
  }

  render();
</script>
</body>
</html>